<!DOCTYPE html>
<html>
  <head>
    <title>ffmprovisr</title>
    <meta charset="utf-8">

    <link href="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
    <link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Sanchez' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/css.css">
    <link href="css/jquery.steps.css" rel="stylesheet" >

    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script src="js/js.js"></script>
    <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
  </head>

  <div class="container">

  <div class="text-center">
    <h1>➺ ffmprovisr ❥</h1>
    <br/>
  </div>

<!-- BUTTONS! -->
<div class="row">

       <div class="well col-md-3 col-md-offset-0">
        <br>
          <h5>Making FFmpeg Easier</h5>
          <p>FFmpeg is a powerful tool for manipulating audiovisual files. Unfortunately, it also has a steep learning curve, especially for users unfamiliar with a command line interface. This app helps users through the command generation process so that more people can reap the benefits of FFmpeg. </p>
          <p>This project is very much a work in progress. Each button displays helpful information about how to perform a wide variety of tasks using FFmpeg. To use this site, click on the task you would like to perform. A new window will open up with a sample command and a description of how that command works. You can copy this command, and after specifying an [input] and possibly an [output], you can then use this command in a Terminal.</p>
          <p>For FFmpeg basics, check out the program's <a href="https://www.ffmpeg.org/">official website.</a></p>
          <p>For Bash and command line basics, try the <a href="http://cli.learncodethehardway.org/book/">Command Line Crash Course</a></p>
      </div>

      <div class="well col-md-6 col-md-offset-2">
          <h3>What do you want to do?</h3>
          <h5>Select from the following.</h5>

<!-- sample example -->
<!-- <span data-toggle="modal" data-target=".*****unique name*****"><button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="bottom" title="*****Hover-over description*****">*****Small title****</button></span>
Change the above data-target field, the button text, and the below div class (the word after modal fade)
<div class="modal fade *****unique name*****" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      where the text goes
      <div class="well">
        <h3>*****Longer title*****</h3>

        <p>
          <code>ffmpeg -i [sample file path]</code>
        </p>

        <p>This is all about info! This is all about info! This is all about info! This is all about info! This is all about info! This is all about info! This is all about info! This is all about info! This is all about info! This is all about info! This is all about info! This is all about info! This is all about info! This is all about info! </p>

        <ul>
          <li>ffmpeg : starts the command</li>
          <li>-i : i for info dudes!</li>
          <li>[sample file path] : path to sample file</li>
        </ul>

      </div>
    </div>
  </div>
</div> -->
<!-- ends sample example -->


<!-- Create GIF -->
<span data-toggle="modal" data-target=".create_gif"><button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="bottom" title="Create a GIF from a video">Create GIF</button></span>
<!-- Change the above data-target field, the button text, and the below div class (the word after modal fade) -->
<div class="modal fade create_gif" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <!-- where the text goes -->
      <div class="well">
        <h3>Create GIF</h3>

        <p>Part 1: Create 3 second clip from an existing source file (no audio necessary) </p>

        <p>
          <code>ffmpeg -ss HH:MM:SS -i input.mov -c:v copy -c:a copy -t 3 output.mov</code>
        </p>

        <ul>
          <li>ffmpeg : starts the command</li>
          <li>-ss HH:MM:SS: The starting point of the gift</li>
          <li>-t 3: the number of seconds after the starting point repeated in the gif</li>
        </ul>

        <p>Part 2: Make the gif</p>

        <p>
          <code>ffmpeg -i input.mov -vf scale=500:-1 -t 10 -r 30 output.gif</code>
        </p>

        <ul>
          <li>ffmpeg : starts the command</li>
          <li>-vf scale: width:height in pixels (a negative number keeps it in proportion)</li>
          <li>-t 10: maximum length of running time in seconds</li>
          <li>-r 30: run at 30 frames per second</li>
        </ul>

      </div>
    </div>
  </div>
</div>
<!-- ends Create GIF -->


<!-- WAV to MP3 -->
<span data-toggle="modal" data-target=".wav_to_mp3"><button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="bottom" title="Converts WAV to MP3">WAV to MP3</button></span>
<div class="modal fade wav_to_mp3" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <!-- where the text goes -->
      <div class="well">
        <h3>WAV to MP3</h3>

        <p>
          <code>ffmpeg -i [inputfile.wav] -sample_fmt s16p -ar 44100 [outputfile.mp3]</code>
        </p>

        <p>This will convert your wav files to mp3s.</p>

        <ul>
          <li>ffmpeg : starts the command</li>
          <li>-i for input</li>
          <li>[inputfile.wav] : file you would like to convert to mp3</li>
          <li>-sample_fmt s16p: sample format. This will give you 16 bit audio (To see a list of supported sample formats, type:  ffmpeg -sample_fmts)</li>
          <li>-ar 44100 : audio sampling frequency (44.1 kHz is the CD quality)</li>
          <li>[outputfile.mp3] : outputname and format</li>
        </ul>

      </div>
    </div>
  </div>
</div>
<!-- ends WAV to MP3 -->


<!-- batch processing -->
<span data-toggle="modal" data-target=".batch_processing"><button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="bottom" title="FFMPEG batch processing within a single folder">Batch processing</button></span>
<div class="modal fade batch_processing" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <!-- where the text goes -->
      <div class="well">
        <h3>Create Bash Script named “Rewrap.MXF.sh” to do Batch FFMPEG Processing</h3>

        <p>
          <code>for f in *.MXF; do ffmpeg -i "$f" -acodec copy -vcodec copy "${f%.MXF}.mov"; done</code>
        </p>

        <p>Re-wrap .MFX files in a specified directory to .mov files by using this code within a .sh file. The shell script (.sh file) and all MXF files must be contained in the same directory, and the script must be run from the directory itself (cd ~/Desktop/MXF_file_directory). Execute .sh file with the command <code>sh Rewrap-MXF.sh</code></p>
        
        <ul>
          <li>-acodec copy (copy audio codec)</li>
          <li>-vcodec copy (copy video codec)</li>
        </ul>

        <p>Modify the ffmpeg script as needed to perform different transcodes :)</p>
      </div>
    </div>
  </div>
</div>
<!-- ends batch processing -->


<!-- Create frame md5s -->
<span data-toggle="modal" data-target=".create_frame_md5s"><button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="bottom" title="This will create an md5 checksum per frame">Create frame md5s</button></span>
<div class="modal fade create_frame_md5s" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <!-- where the text goes -->
      <div class="well">
        <h3>Create frame md5s</h3>

        <p>
          <code>ffmpeg -i [inputfile.extension] -an -f framemd5 [outputfile.framemd5]</code>
        </p>

        <p>This will create an md5 checksum per frame</p>
        
        <ul>
          <li>ffmpeg: starts the command</li>
          <li>-i for input</li>
          <li>[inputfile.extension]: the file you want to create framemd5 checksums for</li>
          <li>-an: ignores the audio track</li>
          <li>-f framemed5: file type</li>
          <li>[outputfile.framemd5]: output name and format</li>
        </ul>

      </div>
    </div>
  </div>
</div>
<!-- ends Create frame md5s -->


<!-- Transcode to ProRes -->
<span data-toggle="modal" data-target=".to_prores"><button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="bottom" title="This will transcode to deinterlaced Apple ProRes LT">Transcode to ProRes</button></span>
<div class="modal fade to_prores" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <!-- where the text goes -->
      <div class="well">
        <h3>Transcode into a deinterlaced Apple ProRes LT</h3>

        <p>
          <code>ffmpeg -i input.mov -vcodec prores -profile:v 1 -acodec pcm_s16le -vf yadif output.mov</code>
        </p>

        <p>This command transcodes an input file (input.mov) into a deinterlaced Apple ProRes LT .mov file with 16-bit linear PCM encoded audio. The file is deinterlaced using the yadif (Yet Another De-Interlacing Filter) command.</p>
        
        <ul>
          <li>ffmpeg: Calls the program ffmpeg</li>
          <li>-i: Tells ffmpeg to expect an input file</li>
          <li>[inputfile]: Specifies the name and location of the file you want to transcode into ProRes</li>
          <li>-vcodec prores: Tells ffmpeg to transcode the video stream into Apple ProRes</li>
          <li>-profile:v 1: Declares profile of Apple ProRes you want to use. The profiles are explained below:</li>
          <ul>
            <li>0 : ProRes422 (Proxy)</li>
            <li>1 : ProRes422 (LT)</li>
            <li>2 : ProRes422 (Normal)</li>
            <li>3 : ProRes422 (HQ)</li>
          </ul>
          <li>-acodec pcm_s16le: Tells ffmpeg to encode the audio stream in 16-bit Linear PCM</li>
          <li>-vf yadif: Runs a deinterlacing video filter (yet another deinterlacing filter) on the new file</li>
          <li>[output.mov]: Specifies the name, location, and extension of the new ProRes file</li>
        </ul>

      </div>
    </div>
  </div>
</div>
<!-- ends Transcode to ProRes -->


<!-- One thumbnail -->
<span data-toggle="modal" data-target=".one_thumbnail"><button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="bottom" title="Export one thumbnail per video file">One thumbnail</button></span>

<div class="modal fade one_thumbnail" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="well">
        <h3>One thumbnail</h3>

        <p>
          <code>ffmpeg -i [file path] -ss 00:00:20 -f image2 -vframes 1 thumb.png
          </code></p>

        <p>This command will grab a thumbnail 20 seconds into the video.</p>

        <ul>
          <li>ffmpeg: calls the program</li>
          <li>-i for input</li>
          <li>-ss 00:00:20: seeks video file to 20 seconds into the video </li>
          <li>-f image2: Forces the file format. image2 is an image file demuxer.</li>
          <li>-vframes 1: sets the number of frames (in this example, one frame)</li>
          <li>thumb.png: output name and format</li>
        </ul>
      </div>
    </div>
  </div>
</div>
<!-- ends One thumbnail -->

<!-- Multi thumbnail -->
<span data-toggle="modal" data-target=".multi_thumbnail"><button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="bottom" title="Export many thumbnails per video file">Many thumbnails</button></span>

<div class="modal fade multi_thumbnail" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <!-- where the text goes -->
      <div class="well">
      <h3>Many thumbnails</h3>
        <p>
          <code>ffmpeg -i {path/inputfile.extension} -f image2 -vf fps=fps=1/60 out%d.png
          </code>
        </p>

        <p>This will grab a thumbnail every minute and output sequential png files.</p>

        <ul>
          <li>ffmpeg: calls the program</li>
          <li>-i for input</li>
          <li>-ss 00:00:20: seeks video file to 20 seconds into the video</li>
          <li>-f image2: Forces the file format. image2 is an image file demuxer</li>
          <li>-vf fps=fps=1/60: -vf is an alias for -filter:v, which creates a filtergraph to use for the streams. The rest of the command identifies filtering by frames per second, and sets the frames per second at 1/60 (which is one per minute).</li>
          <li>out%d.png: Names the output file. The %d is a regular expression that adds a number (d is for digit) and increments with each frame (out1.png, out2.png, out3.png…)</li>
        </ul>
      </div>
    </div>
  </div>
</div>
<!-- ends Multi thumbnail -->

<!-- Pull specs -->
<span data-toggle="modal" data-target=".pull_specs"><button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="bottom" title="Pull specs from video file">Pull specs</button></span>

<div class="modal fade pull_specs" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <!-- where the text goes -->
      <div class="well">
        <h3>Pull specs from video file</h3>
        <p><code>ffprobe -i filename.avi -show_format -show_streams -print_format xml</code></p>

        <p>This command extracts technical metadata from a video file and displays it in xml. </p>
        <p>ffmpeg documentation on ffprobe (full list of flags, commands, <a href="https://www.ffmpeg.org/ffprobe.html">https://www.ffmpeg.org/ffprobe.html</a>) </p>

        <ul>
          <li>ffprobe: calls the program</li>
          <li>-i:  tells ffprobe to expect input files</li>
          <li>-show_format: outputs file container</li>
          <li>-show_streams: outputs audio and video codec</li>
          <li>-show_data: adds “hexdump” to show_streams command output</li>
          <li>-print_format: Set the output printing format (in this example “xml”; “json“ and “flat“ are other output formats)</li>
        </ul>
      </div>
    </div>
  </div>
</div>
<!-- ends Pull specs -->

<!-- Join files together -->
<span data-toggle="modal" data-target=".join_files"><button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="bottom" title="Join (concatenate) two or more files into a single file">Join files together</button></span>

<div class="modal fade join_files" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <!-- where the text goes -->
      <div class="well">
        <h3>Join files together</h3>
        <p><code>ffmpeg -f concat -i mylist.txt -c copy [output] </code></p>

        <p>This command takes two or more files of the same file type and joins them together to make a single file. All that the program needs is a text file with a list specifying the files that should be joined.  However, it only works properly if the files to be combined have the exact same codec and technical specifications. Be careful, ffmpeg may appear to have successfully joined two video files with different codecs, but may only bring over the audio from the second file or have other weird behaviors. Don’t use this command for joining files with different codecs and technical specs and always preview your resulting video file!
</p>
        <p>ffmpeg documentation on concatenating files (full list of flags, commands, <a href="https://trac.ffmpeg.org/wiki/Concatenate">https://trac.ffmpeg.org/wiki/Concatenate</a>) </p>

        <ul>
         <li>ffmpeg: calls the program</li>
         <li>-f: forces ffmpeg to keep the same file format of the joined files</li>
         <li>concat: ffmpeg’s concatenate command. This tells ffmpeg to join the files.</li>
         <li>-i: tells ffmpeg to expect input files</li>
         <li>mylist.txt: specifies the location of a text file with a list of files to be concatenated. You should create a text file that is formatted as follows:</li>
            <ul>
              <li>file [path to file 1]</li>
              <li>file [path to file 2]</li>
            </ul>
         <li>-c copy: specifies the encoder for the output file by telling ffmpeg to copy the codecs of the original files and use them for the output file</li>
         <li>[output]: specifies the filename and location for the output file</li>
        </ul>
      </div>
    </div>
  </div>
</div>
<!-- ends Join files together -->


<!-- Excerpt from beginning -->
<span data-toggle="modal" data-target=".excerpt_from_start"><button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="bottom" title="Create an excerpt, starting from the beginning of the file">Excerpt from beginning</button></span>

<div class="modal fade excerpt_from_start" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <!-- where the text goes -->
      <div class="well">
        <h3>Excerpt from beginning</h3>
        <p><code>ffmpeg -i [input file] -t 5 -c copy [output]</code></p>

        <p>This command captures a certain portion of a video file, starting from the beginning and continuing for the amount of time (in seconds) specified in the script. This can be used to create a preview file, or to remove unwanted content from the end of the file. To be more specific, use timecode, such as 00:00:05. </p>

        <ul>
         <li>ffmpeg: Calls the program ffmpeg</li>
		 <li>-i: Tells ffmpeg to expect input files</li>
		 <li>[input file]: Specifies the location of the file you want to capture a clip from</li>
		 <li>-t 5: Tells ffmpeg to stop copying from the input file after a certain time, and specifies the number of seconds after which to stop copying. In this case, 5 seconds is specified</li>
		 <li>-c copy: Specifies the encoder for the output file by telling ffmpeg to copy the codecs of the original file and use them for the new output file</li>
		 <li>[output]: Specifies the filename and location for the new file</li>
        </ul>
      </div>
    </div>
  </div>
</div>
<!-- ends Excerpt from beginning -->


<!-- Excerpt from middle -->
<span data-toggle="modal" data-target=".excerpt_from_middle"><button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="bottom" title="Capture five seconds from the middle of a video file">Excerpt from middle</button></span>

<div class="modal fade excerpt_from_middle" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <!-- where the text goes -->
      <div class="well">
        <h3>Excerpt from middle</h3>
        <p><code>ffmpeg -i [input file] -ss 5 -t 5 -c copy [output]</code></p>

        <p>This command captures a certain portion of a video file, starting from a designated point in the file and taking an excerpt as long as the amount of time (in seconds) specified in the script. This can be used to create a preview or clip out a desired segment. To be more specific, use timecode, such as 00:00:05. </p>

        <ul>
         <li>ffmpeg: Calls the program ffmpeg</li>
		 <li>-i: Tells ffmpeg to expect input files</li>
		 <li>[input file]: Specifies the location of the file you want to capture a clip from</li>
		 <li>-ss 5: Tells ffmpeg what timecode in the file to look for to start copying, and specifies the number of seconds into the video that ffmpeg should start copying. To be more specific, you can use timecode such as 00:00:05</li>
		 <li>-t 5: Tells ffmpeg to stop copying from the input file after a certain time, and specifies the number of seconds after which to stop copying. In this case, 5 seconds is specified</li>
		 <li>-c copy: Specifies the encoder for the output file by telling ffmpeg to copy the codecs of the original file and use them for the new output file</li>
		 <li>[output]: Specifies the filename and location for the new file</li>
        </ul>
      </div>
    </div>
  </div>
</div>
<!-- ends Excerpt from middle -->


<!-- Excerpt to end -->
<span data-toggle="modal" data-target=".excerpt_to_end"><button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="bottom" title="Create a new video file with the first five seconds trimmed off the original">Excerpt to end</button></span>

<div class="modal fade excerpt_to_end" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <!-- where the text goes -->
      <div class="well">
        <h3>Excerpt to end</h3>
        <p><code>ffmpeg -i [input file] -ss 5 -c copy [output]</code></p>

        <p>This command copies a video file starting from a specified time, removing the first few seconds from the output. This can be used to create an excerpt, or remove unwanted content from the beginning of a video file.</p>


        <ul>
         <li>ffmpeg: Calls the program ffmpeg</li>
		 <li>-i: Tells ffmpeg to expect input files</li>
		 <li>[input file]: Specifies the location of the file you want to capture a clip from</li>
		 <li>-ss 5: Tells ffmpeg what timecode in the file to look for to start copying, and specifies the number of seconds into the video that ffmpeg should start copying. To be more specific, you can use timecode such as 00:00:05</li>
		 <li>-t 5: Tells ffmpeg to stop copying from the input file after a certain time, and specifies the number of seconds after which to stop copying. In this case, 5 seconds is specified</li>
		 <li>-c copy: Specifies the encoder for the output file by telling ffmpeg to copy the codecs of the original file and use them for the new output file</li>
		 <li>[output]: Specifies the filename and location for the new file</li>
        </ul>
      </div>
    </div>
  </div>
</div>
<!-- ends Excerpt to end -->

<!-- Split audio and video tracks -->
<span data-toggle="modal" data-target=".split_audio_video"><button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="bottom" title="Create separate audio and video tracks from an audiovisual file">Split audio and video tracks</button></span>

<div class="modal fade split_audio_video" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <!-- where the text goes -->
      <div class="well">
        <h3>Split audio and video tracks</h3>
        <p><code>ffmpeg -i [input file] -map 0:0 [video output file] -map 0:1 [audio output file] </code></p>

        <p>This command splits the original input file into a video and audio stream. The -map command identifies which streams are mapped to which file. To ensure that you’re mapping the right streams to the right file, run ffprobe before writing the script to identify which stream is 0:0, which is 0:1, etc. </p>

        <ul>
        <li>ffmpeg: calls the program</li>
		<li>-i: tells ffmpeg to expect input file</li>	
		<li>[input file]: the file you want to split</li>
		<li>-map 0:0: tells ffmpeg to grab one of the streams, and identifies the first stream (stream 0:0) to map</li>
		<li>[video output file]: desired filename for the video output file</li>
		<li>-map 0:1: tells ffmpeg to grab one of the streams, and identifies the second stream (stream 0:1) to map</li>
		<li>[audio output file]: desired filename for the audio output file</li>
        </ul>
      </div>
    </div>
  </div>
</div>
<!-- ends Split audio and video tracks -->


<!-- Transcode to h.264 -->
<span data-toggle="modal" data-target=".transcode_h264"><button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="bottom" title="Transcode to an h.264 access file">Transcode to h.264</button></span>

<div class="modal fade transcode_h264" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <!-- where the text goes -->
      <div class="well">
        <h3>Transcode to h.264</h3>
        <p><code>ffmpeg -i [input file] -vcodec libx264 -acodec copy [output file.mp4]</code></p>

        <p>This command takes an input file and transcodes it to h.264 with an .mp4 wrapper, keeping the audio the same codec as the original. The libx264 codec defaults to a “medium” preset for compression quality and a CRF of 23. CRF stands for constant rate factor and determines the quality and file size of the resulting h.264 video. A low CRF means high quality and large file size; a high CRF means the opposite.  </p>

        <ul>
        <li>ffmpeg: Calls the program ffmpeg</li>
		<li>-i: Tells ffmpeg to expect an input file</li>
		<li>[input file]: Tells ffmpeg the location of the file you want to process</li>
		<li>-vcodec libx264: Tells ffmpeg to change the video codec of the file to h264 -acodec copy: tells ffmpeg not to change the audio codec</li>
		<li>[output file.mp4]: Specifies the name and location of the new file, including the desired codec extension</li>
        </ul>
        
        <p>In order to use the same basic command to make a higher quality file, you can add some of these presets:</p>
        <p><code>ffmpeg -i [input file] -vcodec libx264 -acodec copy -preset veryslow -crf 18 [output file.mp4]</code></p>
        
        <li>-preset veryslow: This option tells ffmpeg to use the slowest preset possible for the best compression quality</li>
		<li>-crf 18: Specifying a lower CRF will make a larger file with better visual quality</li>
		
		<p>libx264 also defaults to 4:2:2 chroma subsampling. Some versions of Quicktime can't read x264 files in 4:2:2. In order to allow the video to play in all Quicktime players, you can specify 4:2:0 chroma subsampling instead:</p>
		<p><code>ffmpeg -i [input file] -vcodec libx264 -pix_fmt yuv420p -acodec copy -preset veryslow -crf 18 [output file.mp4]</code></p>

		<li>-pix_fmt yuv420p: Specifies a pixel format of YUV 4:2:0 to allow the file to play in a standard Quicktime player</li>


        
      </div>
    </div>
  </div>
</div>
<!-- ends Transcode to h.264 -->


</div> <!-- end this well (and this ends well) -->
</div> <!-- row -->



    <div class="footer text-center">
      <p>Made with ♥ at <a href="http://wiki.curatecamp.org/index.php/Association_of_Moving_Image_Archivists_%26_Digital_Library_Federation_Hack_Day_2015">AMIA #AVhack15</a></p>
    </div>
  </body>
</html>
